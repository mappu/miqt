// miqt-lupdate parses a Go source file based on MIQT and generates a
// translation (*.ts) file for use with either Qt's lrelease tool and/or Qt
// Linguist.
package main

import (
	"encoding/xml"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

const (
	DefaultComments  bool   = false
	DefaultKeep      bool   = false
	DefaultLanguage  string = ""
	DefaultNoRecurse bool   = false
)

var (
	FoundCounter int
	NewCounter   int
)

type FlagOptions struct {
	AddComments     bool
	ExistingContext []Context
	KeepObsolete    bool
	SkipEmpty       bool
}

func lupdateExec() error {
	inPath := flag.String("InFile", "", "Input file (.go) or directory")
	outT := flag.String("OutFile", "", "(Optional) Path to .ts output file; if omitted, inferred from the input file or directory path")
	comments := flag.Bool("AddComments", DefaultComments, "(Optional) Include code comments in the output file, defaults to false")
	keep := flag.Bool("KeepObsolete", DefaultKeep, "(Optional) Keep obsolete and vanished strings, defaults to false")
	lang := flag.String("Language", DefaultLanguage, "(Optional) Language code, defaults to empty")
	noRecurse := flag.Bool("NoRecursive", DefaultNoRecurse, "(Optional) Disable recursively parsing all subdirectories, defaults to recurse if input is a directory")
	flag.Parse()

	switch *inPath {
	case "":
		flag.Usage()
		os.Exit(1)
	case ".":
		absPath, err := filepath.Abs(".")
		if err != nil {
			return fmt.Errorf("error getting current directory: %w", err)
		}
		inPath = &absPath
	}

	info, err := os.Stat(*inPath)
	if err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("input file '%s' not found", *inPath)
		}
		return fmt.Errorf("error checking '%s'", *inPath)
	}

	var inputFiles []string

	generate := "//go:generate miqt-lupdate -InFile " + strconv.Quote(*inPath)

	if info.IsDir() {
		if *noRecurse {
			files, err := os.ReadDir(*inPath)
			if err != nil {
				return fmt.Errorf("error reading directory '%s'", *inPath)
			}
			for _, file := range files {
				if strings.HasSuffix(file.Name(), ".go") {
					inputFiles = append(inputFiles, filepath.Join(*inPath, file.Name()))
				}
			}
			generate += " -NoRecursive"

		} else {
			err = filepath.Walk(*inPath, func(path string, info os.FileInfo, err error) error {
				if err != nil {
					return err
				}

				if info.IsDir() {
					return nil
				}

				if strings.HasSuffix(path, ".go") {
					inputFiles = append(inputFiles, path)
				}
				return nil
			})
			if err != nil {
				return err
			}
		}

	} else {
		if !strings.HasSuffix(*inPath, ".go") {
			return fmt.Errorf("input file '%s' must be a .go file", *inPath)
		}
		inputFiles = append(inputFiles, *inPath)
		*noRecurse = true
	}

	if *outT != "" && strings.HasSuffix(*outT, ".ts") {
		generate += " -OutFile " + strconv.Quote(*outT)
	} else {
		if !info.IsDir() {
			*outT = strings.TrimSuffix(*inPath, ".go") + ".ts"
		} else {
			*outT = strings.TrimSuffix(*inPath, "/") + ".ts"
		}
	}

	if *comments {
		generate += " -AddComments"
	}

	options := FlagOptions{
		AddComments:  *comments,
		KeepObsolete: *keep,
	}

	var langGen, langHeader string
	if *lang != "" {
		regexp.MustCompile("^(?i)[a-z]{2,3}(?:_[a-z]{2,3})?$").MatchString(*lang)
		if err != nil {
			return fmt.Errorf("error parsing language code: %w", err)
		}
		langGen = " -Language " + strconv.Quote(*lang)
		langHeader = ` language="` + *lang + `"`
	}

	if *keep {
		generate += " -KeepObsolete"

		if _, err := os.Stat(*outT); err == nil {
			existingContext, err := os.ReadFile(*outT)
			if err != nil {
				return fmt.Errorf("error reading existing output file: %w", err)
			}
			imported := TS{}
			if err := xml.Unmarshal(existingContext, &imported); err != nil {
				return fmt.Errorf("error parsing existing context: %w", err)
			}
			options.ExistingContext = imported.Contexts
			for _, context := range options.ExistingContext {
				for range context.Messages {
					FoundCounter++
				}
			}
			if imported.Language != "" {
				langGen = " -Language " + strconv.Quote(imported.Language)
				langHeader = ` language="` + imported.Language + `"`
			}
		}
	}

	generate += langGen

	context, err := parse(inputFiles, options)
	if err != nil {
		return fmt.Errorf("error parsing input files: %w", err)
	}

	rccToStr := strings.Builder{}
	rccToStr.WriteString(`<?xml version="1.0" encoding="utf-8"?>
<!-- Generated by miqt-lupdate. To update this file, run the 'miqt-lupdate' command below. -->
<!-- ` + generate + ` -->
<!DOCTYPE TS>
<TS version="2.1"` + langHeader + `>
` + context + `
</TS>
`)

	if err = os.WriteFile(*outT, []byte(rccToStr.String()), 0644); err != nil {
		return fmt.Errorf("error writing to '%s': %w", *outT, err)
	} else {
		fmt.Println("Wrote to: " + *outT + "\n    Found " + strconv.Itoa(FoundCounter+NewCounter) + " source text(s) " +
			"(" + strconv.Itoa(NewCounter) + " new, " + strconv.Itoa(FoundCounter) + " already existing)")
	}

	return nil
}

func (t *Translation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type Alias Translation
	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(t),
	}

	if err := d.DecodeElement(aux, &start); err != nil {
		return err
	}

	t.Text = strings.TrimSpace(t.Text)
	return nil
}

func main() {
	err := lupdateExec()
	if err != nil {
		fmt.Fprintf(os.Stderr, "miqt-lupdate: %s\n", err.Error())
		os.Exit(1)
	}
}
